"""Output rendering logic for GeoJSON."""
from datetime import datetime
from django.contrib.gis.db.models.functions import AsGeoJSON, Transform

import orjson
from django.db import models
from django.utils.timezone import utc
from gisserver.features import FeatureType
from gisserver import conf

from .base import BytesBuffer, OutputRenderer

WRITE_BUFFER_SIZE = 4096


class GeoJsonRenderer(OutputRenderer):
    """Fast GeoJSON renderer, using a stream response.

    The complex encoding bits are handled by the C-library "orjson"
    and the geojson property of GEOSGeometry.

    NOTE: While Django has a GeoJSON serializer
    (see https://docs.djangoproject.com/en/3.0/ref/contrib/gis/serializers/),
    it does not offer streaming response handling.
    """

    content_type = "application/json; charset=utf-8"

    def decorate_queryset(self, feature_type, queryset):
        """Update the queryset to let the database render the GML output.
        This is far more efficient then GeoDjango's logic, which performs a
        C-API call for every single coordinate of a geometry.
        """
        if not conf.GISSERVER_USE_DB_RENDERING:
            return queryset

        # If desired, the entire FeatureCollection could be rendered
        # in PostgreSQL as well: https://postgis.net/docs/ST_AsGeoJSON.html
        return queryset.annotate(
            _as_db_geojson=self.get_db_as_geojson(feature_type.geometry_field)
        )

    def get_db_as_geojson(self, field):
        if field.srid != self.output_crs.srid:
            value = Transform(field.name, self.output_crs.srid)
        else:
            value = field.name
        return AsGeoJSON(value, precision=16)

    def render_stream(self):
        output = BytesBuffer()

        # Generate the header from a Python dict,
        # but replace the last "}" into a comma, to allow writing more
        header = self.get_header()
        header_bytes = orjson.dumps(header)[:-1]

        # Have a temporary buffer that is written
        output.write(header_bytes)
        output.write(b',\n  "features": [\n')

        # number_returned is None for this data, as the SQL COUNT is avoided.
        number_returned = 0

        # Flatten the results, they are not grouped in a second FeatureCollection
        is_first_collection = True
        for sub_collection in self.collection.results:
            if is_first_collection:
                is_first_collection = False
            else:
                output.write(b",\n")

            is_first = True
            for instance in sub_collection:
                if is_first:
                    is_first = False
                else:
                    output.write(b",\n")

                # The "properties" object is generated by orjson.dumps(),
                # while the "geometry" object uses the built-in 'GEOSGeometry.json' result.
                output.write(self.render_feature(sub_collection.feature_type, instance))
                number_returned += 1

                # Only perform a 'yield' every once in a while,
                # as it goes back-and-forth for writing it to the client.
                if output.is_full():
                    yield output.getvalue()
                    output.clear()

        # Instead of performing an expensive .count() on the start of the page,
        # write this as a last field at the end of the response.
        # This still honors the WFS 30 DRAFT without sacrificing performance.
        output.write(b"\n  ],\n")
        output.write(b'  "numberReturned": %d' % number_returned)
        output.write(b"}\n")
        yield output.getvalue()

    def render_feature(
        self, feature_type: FeatureType, instance: models.Model
    ) -> bytes:
        """Render the output of a single feature"""

        # Get all instance attributes:
        properties = self.get_properties(feature_type, instance)

        return (
            b"    {"
            b'"type": "Feature", '
            b'"id":%b, '
            b'"geometry_name":%b,'
            b'"geometry":%b,'
            b'"properties":%b'
            b"}"
        ) % (
            orjson.dumps(f"{feature_type.name}.{instance.pk}"),
            orjson.dumps(str(instance)),
            self.render_geometry(feature_type, instance),
            orjson.dumps(properties),
        )

    def _format_geojson_value(self, value):
        if isinstance(value, datetime):
            return value.astimezone(utc)
        else:
            return value

    def render_geometry(self, feature_type, instance: models.Model) -> bytes:
        """Generate the proper GeoJSON notation for a geometry"""
        if conf.GISSERVER_USE_DB_RENDERING:
            # Database server rendering
            geojson = instance._as_db_geojson
            return b"null" if geojson is None else geojson.encode()
        else:
            # Local C-API rendering via GEOSGeometry.json
            geometry = getattr(instance, feature_type.geometry_field_name)
            if geometry is None:
                return b"null"

            self.output_crs.apply_to(geometry)
            return geometry.json.encode()

    def get_header(self) -> dict:
        """Generate the header fields.

        The format is based on the WFS 3.0 DRAFT which defines the extra
        pagination headers and numberMatched/numberReturned headers. The
        'numberReturned' is not included here, as it's written by the main
        render method.
        """
        return {
            "type": "FeatureCollection",
            "links": self.get_links(),
            "timeStamp": self._format_geojson_value(self.collection.timestamp),
            "numberMatched": self.collection.number_matched,
            # "numberReturned": is written at the end for better query performance.
            "crs": {"type": "name", "properties": {"name": str(self.output_crs)}},
        }

    def get_links(self) -> list:
        """Generate the pagination links"""
        links = []
        if self.collection.next:
            links.append(
                {
                    "href": self.collection.next,
                    "rel": "next",
                    "type": "application/geo+json",
                    "title": "next page",
                }
            )
        if self.collection.previous:
            links.append(
                {
                    "href": self.collection.previous,
                    "rel": "previous",
                    "type": "application/geo+json",
                    "title": "previous page",
                }
            )
        return links

    def get_properties(self, feature_type: FeatureType, instance: models.Model) -> dict:
        """Collect the data for the 'properties' field"""
        props = {}
        for name in feature_type.fields:
            if name not in feature_type.geometry_field_names:
                try:
                    value = getattr(instance, name)
                except AttributeError:
                    # E.g. Django foreign keys that point to a non-existing member.
                    props[name] = None
                else:
                    props[name] = self._format_geojson_value(value)

        return props
