"""Output rendering logic for GeoJSON."""
from datetime import datetime
from typing import Optional

import orjson
from django.contrib.gis.geos import GEOSGeometry
from django.utils.timezone import utc

from .base import BytesBuffer, GetFeatureOutputRenderer

WRITE_BUFFER_SIZE = 4096


class GeoJsonRenderer(GetFeatureOutputRenderer):
    """Fast GeoJSON renderer, using a stream response.

    The complex encoding bits are handled by the C-library "orjson"
    and the geojson property of GEOSGeometry.

    NOTE: While Django has a GeoJSON serializer
    (see https://docs.djangoproject.com/en/3.0/ref/contrib/gis/serializers/),
    it does not offer streaming response handling.
    """

    content_type = "application/json; charset=utf-8"

    def render_get_feature(
        self, feature_collections, number_matched, number_returned, next, previous
    ):
        crs = orjson.dumps(str(self.output_crs))

        # Have a temporary buffer that is written
        output = BytesBuffer()
        output.write(
            (
                b"{\n"
                b'  "type": "FeatureCollection",\n'
                b'  "totalFeatures": %d,\n'
                b'  "crs": {"type": "name", "properties": {"name": %b}},\n'
                b'  "features": [\n'
            )
            % (number_matched, crs)
        )

        # Flatten the results, they are not grouped in a second FeatureCollection
        is_first_collection = True
        for feature, qs, number_matched in feature_collections:
            if is_first_collection:
                is_first_collection = False
            else:
                output.write(b",\n")

            is_first = True
            for instance in qs:
                # Get geo value
                geo_value = getattr(instance, feature.geometry_field_name)

                # Get all instance attributes:
                properties = {
                    name: self._format_geojson_value(getattr(instance, name))
                    for name, _ in feature.fields
                    if name not in feature.geometry_field_names
                }

                if is_first:
                    is_first = False
                else:
                    output.write(b",\n")

                # The "properties" object is generated by orjson.dumps(),
                # while the "geometry" object built-in using GEOSGeometry.geojson
                output.write(
                    (
                        b"    {"
                        b'"type": "Feature", '
                        b'"id":%b, '
                        b'"geometry_name":%b,'
                        b'"geometry":%b,'
                        b'"properties":%b'
                        b"}"
                    )
                    % (
                        orjson.dumps(f"{feature.name}.{instance.pk}"),
                        orjson.dumps(str(instance)),
                        self._format_geometry(geo_value),
                        orjson.dumps(properties),
                    )
                )

                # Only perform a 'yield' every once in a while,
                # as it goes back-and-forth for writing it to the client.
                if output.is_full():
                    yield output.getvalue()
                    output.clear()

        output.write(b"\n  ]\n")
        output.write(b"}\n")
        yield output.getvalue()

    def _format_geojson_value(self, value):
        if isinstance(value, datetime):
            return value.astimezone(utc)
        else:
            return value

    def _format_geometry(self, geometry: Optional[GEOSGeometry]) -> bytes:
        """Generate the proper GeoJSON notation for a geometry"""
        if geometry is None:
            return b"null"

        self.output_crs.apply_to(geometry)
        return geometry.json.encode()
