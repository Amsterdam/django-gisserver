"""Output rendering logic for GeoJSON."""
from datetime import datetime
from typing import Optional

import orjson
from django.contrib.gis.geos import GEOSGeometry
from django.utils.timezone import utc

from .base import BytesBuffer, GetFeatureOutputRenderer

WRITE_BUFFER_SIZE = 4096


class GeoJsonRenderer(GetFeatureOutputRenderer):
    """Fast GeoJSON renderer, using a stream response.

    The complex encoding bits are handled by the C-library "orjson"
    and the geojson property of GEOSGeometry.

    NOTE: While Django has a GeoJSON serializer
    (see https://docs.djangoproject.com/en/3.0/ref/contrib/gis/serializers/),
    it does not offer streaming response handling.
    """

    content_type = "application/json; charset=utf-8"

    def render_get_feature(
        self, feature_collections, number_matched, number_returned, next, previous
    ):
        output = BytesBuffer()

        # Generate the header from a Python dict,
        # but replace the last "}" into a comma, to allow writing more
        header = self.get_header(number_matched, next, previous)
        header_bytes = orjson.dumps(header)[:-1]

        # Have a temporary buffer that is written
        output.write(header_bytes)
        output.write(b',\n  "features": [\n')

        # number_returned is None for this data, as the SQL COUNT is avoided.
        number_returned = 0

        # Flatten the results, they are not grouped in a second FeatureCollection
        is_first_collection = True
        for feature, qs, number_matched in feature_collections:
            if is_first_collection:
                is_first_collection = False
            else:
                output.write(b",\n")

            is_first = True
            for instance in qs:
                if is_first:
                    is_first = False
                else:
                    output.write(b",\n")

                # The "properties" object is generated by orjson.dumps(),
                # while the "geometry" object built-in using GEOSGeometry.geojson
                output.write(self.render_feature(feature, instance))
                number_returned += 1

                # Only perform a 'yield' every once in a while,
                # as it goes back-and-forth for writing it to the client.
                if output.is_full():
                    yield output.getvalue()
                    output.clear()

        # Instead of performing an expensive .count() on the start of the page,
        # write this as a last field at the end of the response.
        # This still honors the WFS 30 DRAFT without sacrificing performance.
        output.write(b"\n  ],\n")
        output.write(b'  "numberReturned": %d' % number_returned)
        output.write(b"}\n")
        yield output.getvalue()

    def render_feature(self, feature, instance) -> bytes:
        """Render the output of a single feature"""

        # Get geo value
        geo_value = getattr(instance, feature.geometry_field_name)

        # Get all instance attributes:
        properties = self.get_properties(feature, instance)

        return (
            b"    {"
            b'"type": "Feature", '
            b'"id":%b, '
            b'"geometry_name":%b,'
            b'"geometry":%b,'
            b'"properties":%b'
            b"}"
        ) % (
            orjson.dumps(f"{feature.name}.{instance.pk}"),
            orjson.dumps(str(instance)),
            self.render_geometry(geo_value),
            orjson.dumps(properties),
        )

    def _format_geojson_value(self, value):
        if isinstance(value, datetime):
            return value.astimezone(utc)
        else:
            return value

    def render_geometry(self, geometry: Optional[GEOSGeometry]) -> bytes:
        """Generate the proper GeoJSON notation for a geometry"""
        if geometry is None:
            return b"null"

        self.output_crs.apply_to(geometry)
        return geometry.json.encode()

    def get_header(self, number_matched, next, previous) -> dict:
        """Generate the header fields.

        The format is based on the WFS 3.0 DRAFT which defines the extra
        pagination headers and numberMatched/numberReturned headers. The
        'numberReturned' is not included here, as it's written by the main
        render method.
        """
        return {
            "type": "FeatureCollection",
            "links": self.get_links(next, previous),
            "timeStamp": self._format_geojson_value(self.timestamp),
            "numberMatched": number_matched,
            # "numberReturned": is written at the end for better query performance.
            "crs": {"type": "name", "properties": {"name": str(self.output_crs)}},
        }

    def get_links(self, next, previous) -> list:
        """Generate the pagination links"""
        links = []
        if next:
            links.append(
                {
                    "href": next,
                    "rel": "next",
                    "type": "application/geo+json",
                    "title": "next page",
                }
            )
        if previous:
            links.append(
                {
                    "href": previous,
                    "rel": "previous",
                    "type": "application/geo+json",
                    "title": "previous page",
                }
            )
        return links

    def get_properties(self, feature, instance) -> dict:
        """Collect the data for the 'properties' field"""
        return {
            name: self._format_geojson_value(getattr(instance, name))
            for name, _ in feature.fields
            if name not in feature.geometry_field_names
        }
